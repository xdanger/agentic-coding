# AI/Agentic Coding is the future

对于未来的判断：

1. LLMs 的智力在未来会迅速提升，很快就会在 coding 能力上超过全世界最顶尖的程序员。
2. 未来软件工程的组织方式，会从面向人类转变为面向 AI/Agent —— 所有软件工程中执行的部分：coding, documentation, testing, debugging, etc. 都会由 AI/Agent 来完成，而人类的重点将转移到设计面向 AI/Agent 的架构（管理好目录结构、文档、历史记录），以及 review AI/Agent 的输出。

## AI/Agentic Coding 与传统软件工程的优劣势比较

### 优势

- 速度是人类的 100x。不仅编写代码快，而且设计、重构、测试、管理文档 …… 都很快；
- 代码质量、文档质量有底线；代码、文档的格式能遵守严格的标准。

### 劣势

目前，AI/Agentic Coding 在实用性上受限于：

- 缺乏对整个项目全局的理解，往往只关注完成当前的任务；
- 缺乏对人类意图的理解，往往只能完成人类 prompt 的表面工作；
- 缺乏对仓库历史的长期记忆，因此缺乏长期维护的能力，往往只能完成短期任务；
- 缺乏为减少将来的工作而进行优化的意识 —— 不会整理仓库、删除不必要的文件、重构代码、更新注释和文档；
- 如果人工对于仓库手动做了修改，AI/Agent 很难获得这部分信息，因此对于项目的过程的记忆是不完整的。

### 更像是在用 freelancer

其实，面向 AI/Agent 的工作方式非常像使用 freelancer。

- 是一个 24/7 可以响应的、劳动力带宽几乎无限的一群 freelancer；
- 这群 freelancer 的活不仅质量高、还非常便宜；
- 但是这群 freelancer 只关注完成你给的特定任务，如果没有具体的 prompt，他们不会想着需要在达成全局目标（或约束）的情况下完成任务，也不会想到我完成之后如何让其他人能方便地接手。

## 解决办法：Agentic Coding 最佳实践框架

以下是系统性解决 Agentic Coding 劣势的框架方案，通过结构化的原则和实践来弥补 AI/Agent 的局限性。

### 理想的仓库结构

```
project-root/
├── .github/                         # GitHub 模板和工作流
├── docs/                            # 核心文档
│   ├── architecture/                # 架构文档
│   │   ├── decisions/               # 架构决策记录 (ADRs)
│   │   ├── diagrams/                # 系统图表
│   │   └── overview.md              # 高级架构概述
│   ├── specifications/              # 详细规格说明
│   ├── guides/                      # 开发和使用指南
│   └── HISTORY.md                   # 项目历史和变更记录
├── .agent/                          # Agent 专用资源
│   ├── memory/                      # Agent 的持久记忆
│   ├── guidelines/                  # 编码和风格指南
│   ├── tasks/                       # 任务模板和历史
│   └── context/                     # 全局上下文信息
├── src/                             # 源代码
├── tests/                           # 测试代码
└── README.md                        # 项目概述
```

### 原则 1：增强全局理解

#### 文档标准
- **项目概述**：维护全面的 README.md，明确定义项目目的、目标、架构和关键组件
- **架构地图**：保持最新的系统组件关系图
- **组件文档**：每个组件都必须有自己的文档，解释其目的、接口和集成点
- **决策记录**：使用架构决策记录 (ADRs) 跟踪所有架构决策及其背景和理由
- **依赖图**：维护依赖关系的可视化和文本映射

#### 上下文保存
- **全局上下文文件**：维护 `.agent/context/GLOBAL.md` 文件总结整个项目
- **组件摘要**：创建 `.agent/context/components/` 目录，包含每个系统组件的摘要
- **定期知识图谱**：半自动生成项目的知识图谱
- **边界规范**：定义清晰的组件边界和接口

### 原则 2：理解人类意图

#### 任务规范标准
- **模板化请求**：为常见任务类型创建标准化模板
- **意图文档**：每个任务必须包含明确的"意图"和"上下文"部分
- **验收标准**：为每个任务定义清晰、可测试的验收标准
- **用户故事**：将任务构建为具有明确价值主张的用户故事
- **优先级和依赖**：明确说明任务优先级和依赖关系

#### 反馈机制
- **增量交付**：将任务分解为较小的块，设置反馈检查点
- **进度报告**：标准化进度报告格式
- **替代方案**：提供多种解决方案供人类选择
- **审查请求**：对关键决策明确要求人类审查
- **意图验证**：定期验证与原始意图的一致性

### 原则 3：仓库历史记忆

#### 历史管理
- **结构化提交消息**：遵循标准格式（如约定式提交 Conventional Commits）
- **自动变更日志**：自动生成和维护 CHANGELOG.md
- **历史摘要**：定期生成项目演变摘要
- **里程碑文档**：记录关键里程碑和版本转换
- **版本标签**：使用语义化版本控制，附详细发布说明

#### 知识保存
- **决策日志**：维护关键决策的按时间顺序记录及其上下文
- **参考文档**：将代码与文档相互链接
- **历史上下文**：在组件文档中包含"历史"部分
- **迁移指南**：记录主要版本之间的迁移路径
- **弃用功能**：跟踪并记录弃用功能及原因

### 原则 4：未来工作优化

#### 代码质量管理
- **技术债务跟踪**：维护 `.agent/debt/` 目录，记录技术债务
- **重构机会**：记录潜在的重构机会及其好处
- **代码质量指标**：跟踪并报告代码质量指标随时间变化情况
- **测试覆盖率**：每次更改都要维持或提高测试覆盖率
- **性能基准**：跟踪关键操作的性能指标

#### 项目维护
- **定期清理周期**：安排定期清理任务，删除未使用的代码
- **文档时效性**：随代码变更验证并更新文档
- **依赖更新**：定期审查并更新依赖
- **破坏性变更**：跟踪潜在的未来破坏性变更
- **可扩展性规划**：记录预期的扩展挑战和解决方案

### 原则 5：手动变更集成

#### 变更跟踪
- **手动变更日志**：为手动实现的变更创建标准化日志
- **变更协调**：定期协调手动变更与文档
- **版本同步**：确保文档版本与代码版本匹配
- **一致性检查**：实施自动检查，确保代码和文档之间的一致性
- **集成指南**：提供清晰的手动变更集成指南

## 实施指南

要在项目中实施此框架，请按照以下步骤操作：

1. **创建基础结构**：按照上述结构设置项目仓库
2. **定义项目标准**：为您的项目自定义上述原则
3. **集成工具**：设置自动化工具来支持这些原则
4. **团队培训**：确保所有团队成员了解如何与 AI/Agent 协作
5. **逐步改进**：定期评估框架效果并进行调整

通过系统地实施这些原则，可以最大限度地发挥 Agentic Coding 的优势，同时最小化其劣势，创建更高效、更可维护的软件开发流程。